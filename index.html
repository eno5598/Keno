<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO – Kombinationen suchen + Tipp prüfen</title>
<style>
  body{margin:0;padding:16px;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0b1220;color:#e5e7eb}
  .box{max-width:900px;margin:0 auto;background:#111827;border:1px solid #223046;border-radius:10px;padding:14px}
  h1{margin:0 0 10px}
  label{display:block;margin:8px 0 4px;color:#a1a1aa}
  input[type="file"],input[type="number"],input[type="text"],textarea{width:100%;box-sizing:border-box;padding:10px;border-radius:8px;border:1px solid #263041;background:#0b1220;color:#e5e7eb}
  a{color:#93c5fd;text-decoration:none}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 180px}
  button{padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .secondary{background:#1f2937;color:#e5e7eb;border:1px solid #263041}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:#0b1220;border:1px solid #263041;border-radius:8px;padding:8px;white-space:pre-wrap}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace;white-space:pre}
  .hint{color:#9ca3af;font-size:14px;margin-top:4px}
  .pad{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0}
  .pad button{min-width:56px}
  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .chip{background:#0b1220;border:1px solid #263041;border-radius:999px;padding:6px 10px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#0b1220;border:1px solid #263041;margin-left:8px}
  .stack{display:flex;gap:8px;align-items:center}
  .stack input{max-width:160px}
  .section{margin-top:12px;padding-top:8px;border-top:1px dashed #2a3648}
  .ok{color:#34d399}
  .warn{color:#fbbf24}
  .err{color:#f87171}
</style>
</head>
<body>
  <div class="box">
    <h1>KENO – Kombinationen suchen</h1>

    <label>Archiv-CSV hochladen (eine Spalte mit Zahlen wie „1-4-9-…“)</label>
    <input type="file" id="file"
      accept=".csv,.txt,text/csv,application/csv,application/vnd.ms-excel,application/octet-stream,text/plain">
    <div class="hint">CSV einmal laden → bleibt lokal im Browser gespeichert (kein Upload ins Internet).</div>

    <!-- Muster optional -->
    <div class="section">
      <label><input type="checkbox" id="usePattern"> Muster-Abstände verwenden (optional)</label>
      <div id="patternBox" style="display:none">
        <label>Abstände anklicken oder als Liste eingeben</label>
        <div class="pad">
          <button class="secondary gap-btn" data-gap="1">+1</button>
          <button class="secondary gap-btn" data-gap="2">+2</button>
          <button class="secondary gap-btn" data-gap="3">+3</button>
          <button class="secondary gap-btn" data-gap="4">+4</button>
          <button class="secondary gap-btn" data-gap="5">+5</button>
          <button class="secondary gap-btn" data-gap="10">+10</button>
          <button class="secondary gap-btn" data-gap="20">+20</button>
          <span class="stack" style="flex:1">
            <span class="hint">Liste (z. B. 1,5,6,2,20,4,1,1,2):</span>
            <input type="text" id="gapList" placeholder="1,5,6,2,20,4,1,1,2">
            <button id="gapApply" class="secondary">Muster übernehmen</button>
          </span>
          <span class="stack">
            <span class="hint">einzeln:</span>
            <input type="number" id="gapCustom" min="1" value="6">
            <button id="gapAdd" class="secondary">+ hinzufügen</button>
          </span>
          <button id="gapUndo" class="danger">↶ Rückgängig</button>
          <button id="gapClear" class="danger">✖️ Alles löschen</button>
        </div>
        <div class="chips" id="chips"></div>
        <div class="hint">Muster erzeugt <span id="sOut" class="badge">S = 1 Zahl</span> (Felder = Abstände + 1)</div>

        <div class="row">
          <div>
            <label>Startwert-Schrittweite</label>
            <input type="number" id="step" value="1" min="1" max="10">
          </div>
          <div>
            <label>Wieviele Ergebnisse (Limit)</label>
            <input type="number" id="limit" value="200" min="1" max="5000">
          </div>
        </div>
        <div class="hint">Im Muster-Modus wird das S-Feld unten ignoriert (S = Abstände + 1).</div>
      </div>
    </div>

    <!-- Zufallsmodus-Einstellungen -->
    <div class="row section">
      <div>
        <label>Kombi-Größe S</label>
        <input type="number" id="size" value="10" min="1" max="20">
      </div>
      <div>
        <label>Max. erlaubte Überschneidung (0–S)</label>
        <input type="number" id="maxOv" value="7" min="0" max="20">
      </div>
      <div>
        <label>Wieviele Ergebnisse</label>
        <input type="number" id="want" value="10" min="1" max="1000">
      </div>
      <div>
        <label>Max. Versuche</label>
        <input type="number" id="tries" value="60000" min="1000" step="1000">
      </div>
    </div>

    <!-- Bereich + Seed -->
    <div class="row">
      <div>
        <label>Zahlenbereich – Von</label>
        <input type="number" id="rangeFrom" value="1" min="1" max="200">
      </div>
      <div>
        <label>Zahlenbereich – Bis</label>
        <input type="number" id="rangeTo" value="70" min="1" max="200">
      </div>
      <div>
        <label>Seed (optional, reproduzierbar)</label>
        <input type="number" id="seed" value="1" min="0">
      </div>
    </div>

    <!-- Tipp prüfen -->
    <div class="section">
      <h3 style="margin:0 0 6px">Tipp prüfen</h3>
      <label>Dein Tipp (Zahlen mit Leerzeichen oder Komma trennen)</label>
      <input type="text" id="tipInput" placeholder="z. B. 10 11 16 22 24 44 48 49 50 52">
      <div class="row">
        <div>
          <label>Grenzen für Auswertung</label>
          <input type="number" id="thr7" value="7" min="1" max="20">
          <div class="hint">Zählt Ziehungen mit ≥ diesem Wert (Standard: 7 und 8 werden angezeigt)</div>
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="checkTip" class="secondary">Tipp analysieren</button>
      </div>
      <div id="tipStatus" class="status" style="display:none"></div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="go" class="primary">Generieren</button>
      <button id="save" class="secondary">Als CSV speichern</button>
      <button id="clearCache" class="danger">Archiv aus Browser löschen</button>
    </div>

    <div id="status" class="status">Bereit. (Kein Archiv geladen)</div>
    <div id="results" class="results"></div>
  </div>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const CACHE_KEY = "keno_archive_draws_min_v1";
  const PATTERN_KEY = "keno_pattern_min_v1";
  const USEPAT_KEY = "keno_use_pattern_min_v1";

  let g_draws = [];    // nur häufigste Ziehungsgröße
  let g_drawSize = 0;
  let g_pattern = [];  // Abstände

  // ---- CSV ----
  function autoDelim(text){
    const cand=[",",";","|","\t"];
    const first=(text.split(/\r?\n/).find(Boolean)||"");
    let best=",",score=-1;
    for(const d of cand){ const s=first.split(d).length; if(s>score){score=s;best=d;} }
    return best;
  }
  function parseCSV(text,d){ return text.split(/\r?\n/).filter(Boolean).map(r=>r.split(d)); }
  function detectNumbersColumn(rows){
    const maxCols=Math.max(...rows.map(r=>r.length));
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=(r[c]||"").trim();
        if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim());
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }

  // ---- Bitsets/Regeln ----
  const toBits = arr => arr.reduce((b,v)=> b | (1n<<BigInt(v-1)), 0n);
  function overlapUpTo(candBits, drawBits, stopAt){
    let x=candBits&drawBits, c=0;
    while(x){ x&=(x-1n); c++; if(c>stopAt) break; }
    return c;
  }
  function isValid(cand,drawsBits,maxOv){
    const cb=toBits(cand);
    for(const db of drawsBits){ if(overlapUpTo(cb,db,maxOv)>maxOv) return false; }
    return true;
  }
  function rng(seed){ let t=seed>>>0; return ()=>{ t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296; }; }
  function sampleRange(A,B,S,rand){
    const n=B-A+1; if(S>n) return null;
    const a=Array.from({length:n},(_,i)=>A+i);
    for(let i=0;i<S;i++){ const j=i+Math.floor(rand()*(n-i)); [a[i],a[j]]=[a[j],a[i]]; }
    return a.slice(0,S).sort((x,y)=>x-y);
  }
  const uniqBits = arr => Array.from(new Set(arr)).reduce((b,v)=> b|(1n<<BigInt(v-1)),0n);

  // ---- Cache ----
  function saveArchiveToCache(){
    try{ localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now()})); }catch(e){}
  }
  function loadArchiveFromCache(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(!raw) return null;
      const obj=JSON.parse(raw);
      if(!obj || !Array.isArray(obj.draws) || !obj.drawSize) return null;
      return obj;
    }catch(e){ return null; }
  }

  // ---- Datei laden ----
  $("#file").addEventListener("change", async ()=>{
    const f=$("#file").files[0]; if(!f){ return; }
    $("#status").textContent="Lese Datei…";
    try{
      const text=await new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(String(fr.result)); fr.onerror=()=>rej(fr.error); fr.readAsText(f); });
      const rows=parseCSV(text, autoDelim(text));
      const ncol=detectNumbersColumn(rows);
      if(ncol<0) throw new Error("Zahlenspalte nicht erkannt. Erwartet Format wie 1-4-9-…");
      const lists=[];
      for(const r of rows){
        if(ncol>=r.length) continue;
        const cell=(r[ncol]||"").trim(); if(!cell) continue;
        const parts=cell.split("-").map(s=>s.trim()).filter(Boolean);
        if(!parts.every(p=>/^\d+$/.test(p))) continue;
        lists.push(parts.map(Number));
      }
      // häufigste Länge bestimmen
      const cnt=new Map(); for(const a of lists){ cnt.set(a.length,(cnt.get(a.length)||0)+1); }
      g_drawSize=[...cnt.entries()].sort((a,b)=>b[1]-a[1])[0][0];
      g_draws=lists.filter(a=>a.length===g_drawSize).map(a=>Array.from(new Set(a)).sort((x,y)=>x-y));
      saveArchiveToCache();
      $("#status").textContent=`Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize}) · im Browser gespeichert ✅`;
    }catch(e){
      $("#status").textContent="Fehler beim Lesen: "+e.message;
      console.error(e);
    }
  });

  // ---- Init: Cache + Muster + Schalter ----
  (function init(){
    const cached=loadArchiveFromCache();
    if(cached){
      g_draws=cached.draws; g_drawSize=cached.drawSize;
      const saved=new Date(cached.savedAt||Date.now());
      $("#status").textContent=`Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize}) · gespeichert am ${saved.toLocaleDateString()} ${saved.toLocaleTimeString()}`;
    }
    try{
      const raw=localStorage.getItem(PATTERN_KEY);
      g_pattern = raw? JSON.parse(raw) : [];
      if(!Array.isArray(g_pattern)) g_pattern=[];
    }catch(e){ g_pattern=[]; }
    renderPattern();
    const usePat = localStorage.getItem(USEPAT_KEY)==="1";
    $("#usePattern").checked=usePat;
    $("#patternBox").style.display = usePat? "" : "none";
  })();

  // ---- Muster UI ----
  $("#usePattern").addEventListener("change", ()=>{
    const on=$("#usePattern").checked;
    $("#patternBox").style.display=on? "": "none";
    try{ localStorage.setItem(USEPAT_KEY, on? "1":"0"); }catch(e){}
  });

  function renderPattern(){
    const chips=$("#chips"); chips.innerHTML="";
    g_pattern.forEach(v=>{ const el=document.createElement("span"); el.className="chip"; el.textContent=v; chips.appendChild(el); });
    $("#sOut").textContent=`S = ${g_pattern.length+1} Zahlen`;
  }
  function savePattern(){ try{ localStorage.setItem(PATTERN_KEY, JSON.stringify(g_pattern)); }catch(e){} }

  document.querySelectorAll(".gap-btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const v=parseInt(btn.getAttribute("data-gap"),10);
      if(v>0){ g_pattern.push(v); savePattern(); renderPattern(); }
    });
  });
  $("#gapAdd").addEventListener("click", ()=>{
    const v=parseInt($("#gapCustom").value,10);
    if(Number.isInteger(v)&&v>0){ g_pattern.push(v); savePattern(); renderPattern(); }
  });
  function applyGapList(){
    const raw=$("#gapList").value.trim();
    const arr=raw.split(/[,;\s]+/).map(x=>parseInt(x,10)).filter(n=>Number.isInteger(n)&&n>0);
    if(!arr.length){ alert("Kein gültiges Muster erkannt."); return; }
    g_pattern=arr; savePattern(); renderPattern();
    $("#status").textContent=`Muster übernommen: [${g_pattern.join(", ")}] → S=${g_pattern.length+1}`;
  }
  $("#gapApply").addEventListener("click", applyGapList);
  $("#gapList").addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); applyGapList(); }});
  $("#gapUndo").addEventListener("click", ()=>{ g_pattern.pop(); savePattern(); renderPattern(); });
  $("#gapClear").addEventListener("click", ()=>{ g_pattern=[]; savePattern(); renderPattern(); });

  // ---- Tipp prüfen ----
  $("#checkTip").addEventListener("click", ()=>{
    if(!g_draws.length){ alert("Bitte zuerst CSV laden."); return; }
    const raw = $("#tipInput").value.trim();
    if(!raw){ alert("Bitte Tipp eingeben."); return; }
    // Parse Tipp
    let tip = raw.split(/[^0-9]+/).filter(Boolean).map(x=>parseInt(x,10)).filter(n=>Number.isInteger(n));
    tip = Array.from(new Set(tip)).sort((a,b)=>a-b);
    if(tip.length<1){ alert("Kein gültiger Tipp erkannt."); return; }

    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const thr7 = +$("#thr7").value || 7;

    // Bereich-Warnung
    const outOfRange = tip.filter(v=>v<A || v>B);
    const tipInRange = tip.filter(v=>v>=A && v<=B);
    // Archiv auf Bereich clippen (wie bei der Suche)
    const drawsClipped = g_draws.map(a => a.filter(v=>v>=A && v<=B));
    const drawsBits = drawsClipped.map(uniqBits);

    const tipBits = uniqBits(tipInRange);
    let maxOv = 0, cnt7=0, cnt8=0, cnt9=0, cntFull=0;
    const fullNeed = tipInRange.length;
    for(const db of drawsBits){
      // Count overlap, but we can short-circuit with popcount loop:
      let x = tipBits & db, c=0;
      while(x){ x &=(x-1n); c++; }
      if(c>maxOv) maxOv=c;
      if(c>=thr7) cnt7++;
      if(c>=8) cnt8++;
      if(c>=9) cnt9++;
      if(fullNeed>0 && c===fullNeed) cntFull++;
    }

    // Output bauen
    const lines = [];
    lines.push(`Tipp: ${tip.join(" ")}`);
    lines.push(`S = ${tip.length} (im Bereich ${A}–${B}: ${tipInRange.length})`);
    if(outOfRange.length) lines.push(`Hinweis: Außerhalb Bereich ignoriert → [${outOfRange.join(" ")}]`);
    lines.push(`Max. Überschneidung mit einer Ziehung: ${maxOv}`);
    lines.push(`Ziehungen mit ≥${thr7}: ${cnt7}`);
    lines.push(`Ziehungen mit ≥8: ${cnt8}`);
    lines.push(`Ziehungen mit ≥9: ${cnt9}`);
    if(fullNeed>0) lines.push(`Komplett enthalten (=S im Bereich): ${cntFull ? "Ja ("+cntFull+"x)" : "Nein"}`);
    lines.push(`Archiv: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize})`);

    const tipStatus = $("#tipStatus");
    tipStatus.style.display = "";
    tipStatus.textContent = lines.join("\n");
  });

  // ---- Suche (Zufall / Muster) ----
  $("#go").addEventListener("click", ()=>{
    try{
      if(!g_draws.length){ alert("Bitte zuerst CSV laden (oder Cache verwenden)."); return; }
      const A=+$("#rangeFrom").value, B=+$("#rangeTo").value, maxOv=+$("#maxOv").value;
      if(A>B){ alert("Bereich: Von darf nicht größer als Bis sein."); return; }

      const drawsClipped=g_draws.map(a=>a.filter(v=>v>=A&&v<=B));
      const drawsBits=drawsClipped.map(uniqBits);

      const usePat=$("#usePattern").checked;

      if(!usePat){
        const S=+$("#size").value, want=+$("#want").value, tries=+$("#tries").value, seed=+$("#seed").value>>>0;
        if(S>(B-A+1)){ alert("S ist größer als der ausgewählte Zahlenbereich."); return; }
        const rand=rng(seed), seen=new Set(), out=[];
        $("#status").textContent=`Suche (Zufall)… (S=${S}, Bereich ${A}–${B}, max. Überschneidung ≤ ${maxOv})`;
        for(let t=0;t<tries && out.length<want;t++){
          const cand=sampleRange(A,B,S,rand); if(!cand) break;
          const key=cand.join("-"); if(seen.has(key)) continue; seen.add(key);
          if(isValid(cand,drawsBits,maxOv)) out.push(cand);
          if(t%1000===0) $("#status").textContent=`Getestet ${t}/${tries} · Gefunden ${out.length}/${want}`;
        }
        $("#results").textContent= out.map((r,i)=>`Kombi ${i+1} → ${r.join(" ")}`).join("\n") || "(keine Treffer)";
        $("#status").textContent=`Fertig (Zufall). Gefunden: ${out.length}/${want}\nArchiv: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize})`;
      } else {
        if(!g_pattern.length){ alert("Bitte Abstände eingeben/anklicken (Muster darf nicht leer sein)."); return; }
        const step=Math.max(1,+$("#step").value||1);
        const limit=+$("#limit").value||200;
        const inc=g_pattern.reduce((s,x)=>s+x,0);
        const startMax=B-inc; if(startMax<A){ $("#results").textContent="(keine Startwerte im Bereich)"; return; }
        const build=(start)=>{ const seq=[start]; let c=start; for(const d of g_pattern){ c+=d; seq.push(c);} return seq; };
        let tested=0; const out=[];
        $("#status").textContent=`Suche (Muster)… Start ${A}..${startMax} (Schritt ${step})`;
        for(let s=A; s<=startMax; s+=step){
          tested++;
          const seq=build(s);
          if(seq[0]<A||seq[seq.length-1]>B) continue;
          if(isValid(seq,drawsBits,maxOv)){ out.push(seq); if(out.length>=limit) break; }
          if(tested%2000===0) $("#status").textContent=`Getestet ${tested} · Gefunden ${out.length}/${limit}`;
        }
        $("#results").textContent= out.map((r,i)=>`Kombi ${i+1} → ${r.join(" ")}`).join("\n") || "(keine Treffer – Bereich/Überschneidung lockern)";
        $("#status").textContent=`Fertig (Muster). Getestet: ${tested} · Gefunden: ${out.length}/${limit}\nMuster: [${g_pattern.join(", ")}] → S=${g_pattern.length+1}\nArchiv: ${g_draws.length} Ziehungen (Ziehungsgröße ${g_drawSize})`;
      }
    }catch(e){
      $("#status").textContent="Fehler: "+e.message;
      console.error(e);
      alert(e.message);
    }
  });

  // ---- Download ----
  $("#save").addEventListener("click", ()=>{
    const text=$("#results").textContent||"";
    if(!text.trim()){ alert("Keine Ergebnisse."); return; }
    const usePat=$("#usePattern").checked;
    const S= usePat? (g_pattern.length+1) : (+$("#size").value||0);
    const lines=text.split("\n").filter(Boolean).map(line=>{
      const m=line.match(/^Kombi\s+(\d+)\s+→\s+(.*)$/); if(!m) return null;
      return `${m[1]},${m[2].trim().replace(/\s+/g,",")}`;
    }).filter(Boolean);
    const header="nr,"+ (S>0? Array.from({length:S},(_,i)=>"feld"+(i+1)).join(",") : "feld1,feld2,feld3,feld4,feld5,feld6,feld7,feld8,feld9,feld10");
    const csv= header+"\n"+lines.join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download= usePat? "kombinationen_muster.csv":"kombinationen.csv"; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),500);
  });

})();
</script>
</body>
</html>